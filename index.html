<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ミニテトリス</title>
  <style>
    body {
        background-color: #2c3e50;
        font-family: Arial, sans-serif;
        color: #ecf0f1;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        min-height: 100vh;
        max-height: 100vh;
        margin: 0;
        padding: 0;
        user-select: none;
        touch-action: manipulation; /* ダブルタップズーム無効 */
        overflow: hidden; /* 全方向スクロール防止 */
        position: fixed;
        width: 100%;
    }

    h1, h2, h3 { margin: 10px 0; text-align: center; }

    .score {
        font-size: 1.5em;
        margin-bottom: 10px;
    }

    .homeScreen {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .gameScreen {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }

    .game-wrapper {
        display: flex;
        gap: 20px;
    }

    canvas {
        border: 3px solid #34495e;
        background-color: #111;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        border-radius: 5px;
    }

    .control-button, .mode-button, .resume-button, .home-button, .pause-button, .overlay-back-button, .reset-button {
        font-size: 18px;
        padding: 10px 15px;
        margin: 5px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .control-button:hover, .mode-button:hover, .resume-button:hover, .home-button:hover, .pause-button:hover, .overlay-back-button:hover, .reset-button:hover {
        background-color: #2980b9;
    }

    .control-button:active, .mode-button:active, .resume-button:active, .home-button:active, .pause-button:active, .overlay-back-button:active, .reset-button:active {
        background-color: #2980b9;
    }

    .pause-button {
        width: 50px;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .mode-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
    }

    #message-overlay, #pause-menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,0.8);
        z-index: 10;
    }

    .menu-content, .message-content {
        background: #34495e;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    #game-controls {
        display: flex;
        justify-content: center;
        margin-top: 20px;
        gap: 10px;
    }

    .hidden {
        display: none;
    }

    .game-controls-top {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        width: 100%;
        max-width: 600px;
    }

    .game-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }

    .hamburger-icon {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
    }

    .hamburger-line {
        width: 20px;
        height: 3px;
        background-color: white;
        margin: 2px 0;
        border-radius: 1px;
    }
  </style>
</head>
<body>
  <!-- ホーム画面 -->
  <div class="homeScreen">
    <h1>ミニテトリス</h1>
    <div class="mode-buttons">
      <button class="mode-button soloBtn">ソロ</button>
      <button class="mode-button multiBtn">マルチ</button>
    </div>
  </div>

  <!-- ゲーム画面 -->
  <div class="gameScreen hidden">
    <div class="game-controls-top">
      <div class="game-content">
        <canvas id="tetris" width="200" height="400"></canvas>
      </div>
      <div class="game-info">
        <button class="pause-button menu-btn">
          <div class="hamburger-icon">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
          </div>
        </button>
        <div class="score">スコア: <span id="score">0</span></div>
        <div class="next-container">
          <div class="next-block-box">
            <canvas id="next-block-1" width="120" height="120"></canvas>
          </div>
          <div class="next-block-box">
            <canvas id="next-block-2" width="120" height="120"></canvas>
          </div>
        </div>
      </div>
    </div>

    <!-- ゲーム内操作ボタン -->
    <div id="game-controls">
      <button class="control-button" data-key="ArrowLeft">←</button>
      <button class="control-button" data-key="ArrowDown">↓</button>
      <button class="control-button" data-key="ArrowRight">→</button>
      <button class="control-button" data-key="ArrowUp">⟳</button>
      <button class="control-button" data-key="Space">決定</button>
    </div>
  </div>

  <!-- ポーズメニュー -->
  <div id="pause-menu" class="hidden">
    <div class="menu-content">
      <p>一時停止中</p>
      <button class="resume-button">続ける</button>
      <button class="reset-button">リセット</button>
      <button class="home-button">ホームへ</button>
    </div>
  </div>

  <!-- メッセージオーバーレイ -->
  <div id="message-overlay" class="hidden">
    <div class="message-content">
      <p id="message-text"></p>
      <button class="overlay-back-button">戻る</button>
    </div>
  </div>

  <script>
    // --------------------- DOM Elements ---------------------
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const nextCanvas1 = document.getElementById('next-block-1');
    const nextContext1 = nextCanvas1.getContext('2d');
    const nextCanvas2 = document.getElementById('next-block-2');
    const nextContext2 = nextCanvas2.getContext('2d');
    const scoreElement = document.getElementById('score');
    const pauseMenu = document.getElementById('pause-menu');
    const messageOverlay = document.getElementById('message-overlay');
    const messageText = document.getElementById('message-text');
    const homeScreen = document.querySelector(".homeScreen");
    const gameScreen = document.querySelector(".gameScreen");
    const scoreDisplay = document.querySelector(".score");
    const controls = document.getElementById('game-controls');

    // --------------------- Constants ---------------------
    let BLOCK_SIZE = 20;
    const COLS = 10; // 12 → 10に変更
    const ROWS = 20; // 24 → 20に変更
    const INITIAL_DROP_INTERVAL = 1000;
    const DROP_SPEED_INCREMENT = 20;
    const MIN_DROP_INTERVAL = 100;

    // --------------------- Device Detection & Sizing ---------------------
    function getDeviceInfo() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const isMobile = width <= 768;
        const isTablet = width > 768 && width <= 1024;
        const isDesktop = width > 1024;
        
        return { width, height, isMobile, isTablet, isDesktop };
    }

    function calculateOptimalSize() {
        const deviceInfo = getDeviceInfo();
        let optimalBlockSize = 25; // 基本サイズを大きくして見やすく
        
        if (deviceInfo.isMobile) {
            // モバイル：画面幅の65%を10列で割る（さらに小さく調整）
            optimalBlockSize = Math.floor((deviceInfo.width * 0.65) / COLS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 25), 16);
        } else if (deviceInfo.isTablet) {
            // タブレット：少し大きめ
            optimalBlockSize = Math.floor((deviceInfo.width * 0.6) / COLS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 40), 25);
        } else {
            // デスクトップ：大きく表示
            optimalBlockSize = Math.floor((deviceInfo.height * 0.75) / ROWS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 45), 30);
        }
        
        return optimalBlockSize;
    }

    function resizeCanvas() {
        BLOCK_SIZE = calculateOptimalSize();
        const gameWidth = COLS * BLOCK_SIZE;
        const gameHeight = ROWS * BLOCK_SIZE;
        
        canvas.width = gameWidth;
        canvas.height = gameHeight;
        
        // Next canvas サイズも調整（大きくして見やすく）
        const nextSize = Math.max(120, BLOCK_SIZE * 5);
        nextCanvas1.width = nextSize;
        nextCanvas1.height = nextSize;
        nextCanvas2.width = nextSize;
        nextCanvas2.height = nextSize;
        
        console.log(`デバイス情報: ${JSON.stringify(getDeviceInfo())}`);
        console.log(`ブロックサイズ: ${BLOCK_SIZE}px, キャンバス: ${gameWidth}x${gameHeight}, Next: ${nextSize}x${nextSize}`);
    }

    // --------------------- Game State ---------------------
    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let score = 0;
    let isGameOver = false;
    let isPaused = false;
    let dropCounter = 0;
    let dropInterval = INITIAL_DROP_INTERVAL;
    let lastTime = 0;
    let animationFrameId;

    // --------------------- Tetrominos ---------------------
    const tetrominos = [
      {matrix:[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], color:'cyan'},
      {matrix:[[1,1],[1,1]], color:'yellow'},
      {matrix:[[0,1,0],[1,1,1],[0,0,0]], color:'purple'},
      {matrix:[[0,0,1],[1,1,1],[0,0,0]], color:'orange'},
      {matrix:[[1,0,0],[1,1,1],[0,0,0]], color:'blue'},
      {matrix:[[1,1,0],[0,1,1],[0,0,0]], color:'red'},
      {matrix:[[0,1,1],[1,1,0],[0,0,0]], color:'green'}
    ];

    // --------------------- Block Management ---------------------
    let currentBlock = null;
    let nextBlocks = [];
    let lastUsedIndex = -1;

    function createRandomBlock(){
        let index;
        do { index = Math.floor(Math.random()*tetrominos.length); }
        while(index === lastUsedIndex);
        lastUsedIndex = index;
        const t = tetrominos[index];
        return {matrix:t.matrix, color:t.color};
    }

    function getNextBlock(){
        if(nextBlocks.length === 0){
            nextBlocks.push(createRandomBlock());
            nextBlocks.push(createRandomBlock());
        }
        const block = nextBlocks.shift();
        nextBlocks.push(createRandomBlock());
        return {
            matrix:block.matrix,
            color:block.color,
            x:Math.floor(COLS/2)-Math.floor(block.matrix[0].length/2),
            y:0
        };
    }

    function rotate(matrix){
        return matrix[0].map((_,i)=>matrix.map(row=>row[i]).reverse());
    }

    function collide(board, block){
        if(!block) return false;
        for(let y=0;y<block.matrix.length;y++){
            for(let x=0;x<block.matrix[y].length;x++){
                if(block.matrix[y][x] !== 0){
                    const boardX = block.x + x;
                    const boardY = block.y + y;
                    if(boardX<0 || boardX>=COLS || boardY>=ROWS || (boardY>=0 && board[boardY][boardX]!==0)) return true;
                }
            }
        }
        return false;
    }

    function fixBlock(){
        for(let y=0;y<currentBlock.matrix.length;y++){
            for(let x=0;x<currentBlock.matrix[y].length;x++){
                if(currentBlock.matrix[y][x]!==0){
                    board[currentBlock.y+y][currentBlock.x+x] = currentBlock.color;
                }
            }
        }
        let linesCleared = 0;
        for(let y=ROWS-1;y>=0;){
            if(board[y].every(cell=>cell!==0)){
                board.splice(y,1);
                board.unshift(Array(COLS).fill(0));
                linesCleared++;
            } else y--;
        }
        if(linesCleared>0){
            score += 100*linesCleared*linesCleared;
            scoreElement.textContent = score;
            dropInterval = Math.max(dropInterval - DROP_SPEED_INCREMENT, MIN_DROP_INTERVAL);
        }
        currentBlock = getNextBlock();
        if(collide(board,currentBlock)) gameOver();
    }

    function hardDrop(){
        while(!collide(board,currentBlock)) currentBlock.y++;
        currentBlock.y--;
        fixBlock();
    }

    // --------------------- Drawing ---------------------
    function drawBoard(){
        context.fillStyle='#111';
        context.fillRect(0,0,canvas.width,canvas.height);
        for(let y=0;y<ROWS;y++){
            for(let x=0;x<COLS;x++){
                context.strokeStyle='#34495e';
                context.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                if(board[y][x]!==0){
                    context.fillStyle=board[y][x];
                    context.fillRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                    context.strokeStyle='black';
                    context.lineWidth=2;
                    context.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
            }
        }
        const ghost = {...currentBlock};
        while(!collide(board,ghost)) ghost.y++;
        ghost.y--;
        for(let y=0;y<ghost.matrix.length;y++)
            for(let x=0;x<ghost.matrix[y].length;x++)
                if(ghost.matrix[y][x]!==0){
                    context.fillStyle='rgba(255,255,255,0.2)';
                    context.fillRect((ghost.x+x)*BLOCK_SIZE,(ghost.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
        for(let y=0;y<currentBlock.matrix.length;y++)
            for(let x=0;x<currentBlock.matrix[y].length;x++)
                if(currentBlock.matrix[y][x]!==0){
                    context.fillStyle=currentBlock.color;
                    context.fillRect((currentBlock.x+x)*BLOCK_SIZE,(currentBlock.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                    context.strokeStyle='black';
                    context.lineWidth=2;
                    context.strokeRect((currentBlock.x+x)*BLOCK_SIZE,(currentBlock.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
    }

    function drawNext(){
        if (nextBlocks.length === 0) return;
        
        // 1つ目のNext表示
        drawNextBlock(nextContext1, nextBlocks[0], nextCanvas1.width, nextCanvas1.height);
        
        // 2つ目のNext表示
        if (nextBlocks.length > 1) {
            drawNextBlock(nextContext2, nextBlocks[1], nextCanvas2.width, nextCanvas2.height);
        }
    }

    function drawNextBlock(context, block, canvasWidth, canvasHeight) {
        // 背景
        context.fillStyle = '#111';
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // グリッド設定
        const gridCols = 5; // 5x5グリッド
        const gridRows = 5;
        const cellWidth = canvasWidth / gridCols;
        const cellHeight = canvasHeight / gridRows;
        
        // グリッド線を描画
        context.strokeStyle = '#34495e';
        context.lineWidth = 1;
        
        // 縦線
        for (let i = 0; i <= gridCols; i++) {
            const x = i * cellWidth;
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, canvasHeight);
            context.stroke();
        }
        
        // 横線
        for (let i = 0; i <= gridRows; i++) {
            const y = i * cellHeight;
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(canvasWidth, y);
            context.stroke();
        }
        
        // ブロックを中央のグリッドに配置
        const blockMatrix = block.matrix;
        const blockCols = blockMatrix[0].length;
        const blockRows = blockMatrix.length;
        
        // 中央揃えのオフセット計算
        const startCol = Math.floor((gridCols - blockCols) / 2);
        const startRow = Math.floor((gridRows - blockRows) / 2);
        
        // ブロック描画
        for (let y = 0; y < blockRows; y++) {
            for (let x = 0; x < blockCols; x++) {
                if (blockMatrix[y][x] !== 0) {
                    const drawX = (startCol + x) * cellWidth;
                    const drawY = (startRow + y) * cellHeight;
                    
                    // セルの内側に少し余白を持たせて描画
                    const padding = 2;
                    context.fillStyle = block.color;
                    context.fillRect(
                        drawX + padding, 
                        drawY + padding, 
                        cellWidth - padding * 2, 
                        cellHeight - padding * 2
                    );
                    context.strokeStyle = 'black';
                    context.lineWidth = 2;
                    context.strokeRect(
                        drawX + padding, 
                        drawY + padding, 
                        cellWidth - padding * 2, 
                        cellHeight - padding * 2
                    );
                }
            }
        }
    }

    // --------------------- Update Loop ---------------------
    function update(time=0){
        if(isGameOver || isPaused) return;
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if(dropCounter > dropInterval){
            currentBlock.y++;
            if(collide(board,currentBlock)){
                currentBlock.y--;
                fixBlock();
            }
            dropCounter=0;
        }
        drawBoard();
        drawNext();
        animationFrameId = requestAnimationFrame(update);
    }

    // --------------------- Pause & Game Over ---------------------
    function togglePause(){
        isPaused = !isPaused;
        if(isPaused){
            pauseMenu.style.display = 'flex';
            cancelAnimationFrame(animationFrameId);
        } else {
            pauseMenu.style.display = 'none';
            update();
        }
    }

    function gameOver(){
        isGameOver = true;
        cancelAnimationFrame(animationFrameId);
        context.fillStyle='rgba(0,0,0,0.7)';
        context.fillRect(0,0,canvas.width,canvas.height);
        context.fillStyle='white';
        context.font='30px Arial';
        context.textAlign='center';
        context.fillText('ゲームオーバー',canvas.width/2,canvas.height/2);
        setTimeout(resetGame,3000);
    }

    function showMessage(msg) {
        messageText.textContent = msg;
        messageOverlay.style.display = 'flex';
    }

    // --------------------- Reset Game ---------------------
    function resetGame(){
        isGameOver=false;
        isPaused=false;
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        score = 0;
        scoreElement.textContent = score;
        nextBlocks=[];
        lastUsedIndex=-1;
        dropInterval = INITIAL_DROP_INTERVAL;
        dropCounter = 0;
        currentBlock = getNextBlock();
        pauseMenu.style.display = 'none';
        messageOverlay.style.display = 'none';
        update();
    }

    // --------------------- Screen Transitions ---------------------
    function showGameScreen() {
        homeScreen.style.display = 'none';
        gameScreen.style.display = 'flex';
        scoreDisplay.style.display = 'block';
        controls.style.display = 'flex';
        resizeCanvas(); // キャンバスサイズを調整
        resetGame();
    }

    function showHomeScreen() {
        homeScreen.style.display = 'flex';
        gameScreen.style.display = 'none';
        scoreDisplay.style.display = 'none';
        controls.style.display = 'none';
        cancelAnimationFrame(animationFrameId);
        pauseMenu.style.display = 'none';
        messageOverlay.style.display = 'none';
    }

    // --------------------- Event Handlers ---------------------
    document.querySelector(".soloBtn").addEventListener("click", showGameScreen);
    document.querySelector(".multiBtn").addEventListener("click", () => {
        showMessage("マルチプレイは準備中！");
    });

    // --------------------- Resize Handler ---------------------
    window.addEventListener('resize', () => {
        if (gameScreen.style.display !== 'none') {
            resizeCanvas();
        }
    });

    // --------------------- Initialize ---------------------
    resizeCanvas(); // 初期化時にサイズ調整
    document.querySelector(".overlay-back-button").addEventListener("click", () => {
        messageOverlay.style.display = 'none';
    });
    document.querySelector(".resume-button").addEventListener("click", togglePause);
    document.querySelector(".reset-button").addEventListener("click", resetGame);
    document.querySelector(".home-button").addEventListener("click", showHomeScreen);
    document.querySelector(".pause-button").addEventListener("click", togglePause);
    document.querySelectorAll('.control-button').forEach(button => {
        button.addEventListener('click', () => {
            if(isGameOver || isPaused) return;
            switch (button.dataset.key) {
                case 'ArrowLeft':
                    currentBlock.x--;
                    if (collide(board, currentBlock)) currentBlock.x++;
                    break;
                case 'ArrowRight':
                    currentBlock.x++;
                    if (collide(board, currentBlock)) currentBlock.x--;
                    break;
                case 'ArrowDown':
                    currentBlock.y++;
                    if (collide(board, currentBlock)) {
                        currentBlock.y--;
                        fixBlock();
                    }
                    dropCounter = 0;
                    break;
                case 'ArrowUp':
                    const rotated = rotate(currentBlock.matrix);
                    const prev = currentBlock.matrix;
                    currentBlock.matrix = rotated;
                    if (collide(board, currentBlock)) currentBlock.matrix = prev;
                    break;
                case 'Space':
                    hardDrop();
                    dropCounter = 0;
                    break;
            }
        });
    });
    document.addEventListener('keydown', e => {
        if (isGameOver || isPaused) return;
        switch (e.key) {
            case 'ArrowLeft':
                currentBlock.x--;
                if (collide(board, currentBlock)) currentBlock.x++;
                break;
            case 'ArrowRight':
                currentBlock.x++;
                if (collide(board, currentBlock)) currentBlock.x--;
                break;
            case 'ArrowDown':
                currentBlock.y++;
                if (collide(board, currentBlock)) {
                    currentBlock.y--;
                    fixBlock();
                }
                dropCounter = 0;
                break;
            case 'ArrowUp':
                const rotated = rotate(currentBlock.matrix);
                const prev = currentBlock.matrix;
                currentBlock.matrix = rotated;
                if (collide(board, currentBlock)) currentBlock.matrix = prev;
                break;
            case ' ':
                e.preventDefault();
                hardDrop();
                dropCounter = 0;
                break;
            case 'p':
                togglePause();
                break;
        }
    });
  </script>
</body>
</html>