<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ミニテトリス</title>
  <style>
    body {
        background-color: #2c3e50;
        font-family: Arial, sans-serif;
        color: #ecf0f1;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        min-height: 100vh;
        max-height: 100vh;
        margin: 0;
        padding: 0;
        user-select: none;
        touch-action: manipulation; /* ダブルタップズーム無効 */
        overflow: hidden; /* 全方向スクロール防止 */
        position: fixed;
        width: 100%;
    }

    h1, h2, h3 { margin: 10px 0; text-align: center; }

    .score {
        font-size: 1.8em;
        margin-bottom: 15px;
        text-align: center;
        font-weight: bold;
    }

    .homeScreen {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .gameScreen {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }

    .game-wrapper {
        display: flex;
        gap: 20px;
    }

    canvas {
        border: 3px solid #34495e;
        background-color: #111;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        border-radius: 5px;
    }

    .control-button, .mode-button, .resume-button, .home-button, .pause-button, .overlay-back-button, .reset-button {
        font-size: 24px;
        font-weight: bold;
        padding: 15px 25px;
        margin: 8px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        min-width: 60px;
        min-height: 60px;
    }

    .control-button:hover, .mode-button:hover, .resume-button:hover, .home-button:hover, .pause-button:hover, .overlay-back-button:hover, .reset-button:hover {
        background-color: #2980b9;
    }

    .control-button:active, .mode-button:active, .resume-button:active, .home-button:active, .pause-button:active, .overlay-back-button:active, .reset-button:active {
        background-color: #2980b9;
    }

    .pause-button {
        width: 70px;
        height: 70px;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        z-index: 5;
    }

    .mode-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
    }

    .game-controls-top {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        gap: 30px;
        width: 100%;
        max-width: 800px;
    }

    .game-content {
        display: flex;
        align-items: flex-start;
    }

    .game-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin-left: 30px;
    }

    .next-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .next-block-box {
        border: 3px solid #34495e;
        background-color: #111;
        border-radius: 8px;
        padding: 8px;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }

    #message-overlay, #pause-menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        justify-content: center;
        align-items: center;
        background-color: rgba(0,0,0,0.8);
        z-index: 10;
    }

    .menu-content, .message-content {
        background: #34495e;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    #game-controls {
        display: flex;
        justify-content: center;
        margin-top: 20px;
        gap: 10px;
    }

    .hidden {
        display: none;
    }

    .hamburger-icon {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
    }

    .hamburger-line {
        width: 20px;
        height: 3px;
        background-color: white;
        margin: 2px 0;
        border-radius: 1px;
    }

    @media (max-width: 768px) {
        /* ホーム画面でゲーム要素を完全に隠す */
        body:not(.game-active) .gameScreen {
            display: none !important;
        }
        
        body:not(.game-active) #game-controls {
            display: none !important;
        }
        
        /* ゲーム画面でホーム画面を完全に隠す */
        body.game-active .homeScreen {
            display: none !important;
        }
        
        /* ゲーム画面が表示されている時のスタイル */
        body.game-active .gameScreen {
            display: flex !important;
            width: 100%;
            max-width: 100vw;
            height: 100vh;
            overflow: hidden;
            padding: 3px;
            box-sizing: border-box;
            flex-direction: column;
            justify-content: center;
        }
        
        body.game-active .game-controls-top {
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 10px;
            padding: 5px;
            height: auto;
            overflow: hidden;
        }
        
        body.game-active .game-content {
            flex-shrink: 0;
        }
        
        body.game-active .game-info {
            margin-left: 10px;
            order: 0;
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        body.game-active .next-container {
            flex-direction: column;
            gap: 8px;
        }
        
        body.game-active .next-block-box {
            padding: 4px;
        }
        
        body.game-active .next-block-box canvas {
            width: 60px !important;
            height: 60px !important;
        }
        
        body.game-active .pause-button {
            width: 40px;
            height: 40px;
        }
        
        body.game-active .control-button {
            font-size: 16px;
            padding: 8px;
            width: 45px;
            height: 45px;
            min-width: 45px;
            min-height: 45px;
            margin: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        body.game-active .score {
            font-size: 0.9em;
            margin-bottom: 5px;
            text-align: center;
        }
        
        body {
            padding: 0;
        }
        
        /* ゲーム中のみ操作ボタンを表示 */
        body.game-active #game-controls {
            position: fixed !important;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.95);
            border-radius: 6px;
            padding: 5px;
            gap: 5px;
            display: flex !important;
            flex-direction: row;
            justify-content: center;
            max-width: 90%;
            flex-wrap: nowrap;
        }
        
        body.game-active .hamburger-icon {
            width: 16px;
            height: 16px;
        }
        
        body.game-active .hamburger-line {
            width: 12px;
            height: 2px;
        }
        
        /* ホーム画面のスタイルを確実に適用 */
        body:not(.game-active) .homeScreen {
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
            align-items: center !important;
            width: 100% !important;
            height: 100vh !important;
        }
        
        body:not(.game-active) .homeScreen .mode-buttons {
            display: flex !important;
            justify-content: center !important;
            gap: 20px !important;
        }
    }
  </style>
</head>
<body>
  <!-- ホーム画面 -->
  <div class="homeScreen">
    <h1>ミニテトリス</h1>
    <div class="mode-buttons">
      <button class="mode-button soloBtn">ソロ</button>
      <button class="mode-button multiBtn">マルチ</button>
    </div>
  </div>

  <!-- ゲーム画面 -->
  <div class="gameScreen hidden">
    <div class="game-controls-top">
      <div class="game-content">
        <canvas id="tetris" width="200" height="400"></canvas>
      </div>
      <div class="game-info">
        <button class="pause-button menu-btn">
          <div class="hamburger-icon">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
          </div>
        </button>
        <div class="score">
          スコア: <span id="score">0</span><br>
          最大コンボ: <span id="max-combo">0</span>
        </div>
        <div class="next-container">
          <div class="next-block-box">
            <canvas id="next-block-1" width="120" height="120"></canvas>
          </div>
          <div class="next-block-box">
            <canvas id="next-block-2" width="120" height="120"></canvas>
          </div>
        </div>
      </div>
    </div>

    <!-- ゲーム内操作ボタン -->
    <div id="game-controls">
      <button class="control-button" data-key="ArrowLeft">←</button>
      <button class="control-button" data-key="ArrowDown">↓</button>
      <button class="control-button" data-key="ArrowRight">→</button>
      <button class="control-button" data-key="ArrowUp">⟳</button>
      <button class="control-button" data-key="Space">決定</button>
    </div>
  </div>

  <!-- ポーズメニュー -->
  <div id="pause-menu" class="hidden">
    <div class="menu-content">
      <p>一時停止中</p>
      <button class="resume-button">続ける</button>
      <button class="reset-button">リセット</button>
      <button class="home-button">ホームへ</button>
    </div>
  </div>

  <!-- メッセージオーバーレイ -->
  <div id="message-overlay" class="hidden">
    <div class="message-content">
      <p id="message-text"></p>
      <button class="overlay-back-button">戻る</button>
    </div>
  </div>

  <script>
    // --------------------- DOM Elements ---------------------
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const nextCanvas1 = document.getElementById('next-block-1');
    const nextContext1 = nextCanvas1.getContext('2d');
    const nextCanvas2 = document.getElementById('next-block-2');
    const nextContext2 = nextCanvas2.getContext('2d');
    const scoreElement = document.getElementById('score');
    const maxComboElement = document.getElementById('max-combo');
    const pauseMenu = document.getElementById('pause-menu');
    const messageOverlay = document.getElementById('message-overlay');
    const messageText = document.getElementById('message-text');
    const homeScreen = document.querySelector(".homeScreen");
    const gameScreen = document.querySelector(".gameScreen");
    const scoreDisplay = document.querySelector(".score");
    const controls = document.getElementById('game-controls');

    // --------------------- Constants ---------------------
    let BLOCK_SIZE = 20;
    const COLS = 10;
    const ROWS = 20;
    const INITIAL_DROP_INTERVAL = 1000;
    const DROP_SPEED_INCREMENT = 20;
    const MIN_DROP_INTERVAL = 100;

    // --------------------- Device Detection & Sizing ---------------------
    function getDeviceInfo() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const isMobile = width <= 768;
        const isTablet = width > 768 && width <= 1024;
        const isDesktop = width > 1024;
        
        return { width, height, isMobile, isTablet, isDesktop };
    }

    function calculateOptimalSize() {
        const deviceInfo = getDeviceInfo();
        let optimalBlockSize = 25;
        
        if (deviceInfo.isMobile) {
            // モバイル：もっと小さくしてUIが崩れないように
            optimalBlockSize = Math.floor((deviceInfo.width * 0.5) / COLS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 18), 12);
        } else if (deviceInfo.isTablet) {
            optimalBlockSize = Math.floor((deviceInfo.width * 0.6) / COLS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 40), 25);
        } else {
            optimalBlockSize = Math.floor((deviceInfo.height * 0.75) / ROWS);
            optimalBlockSize = Math.max(Math.min(optimalBlockSize, 45), 30);
        }
        
        return optimalBlockSize;
    }

    function resizeCanvas() {
        BLOCK_SIZE = calculateOptimalSize();
        const gameWidth = COLS * BLOCK_SIZE;
        const gameHeight = ROWS * BLOCK_SIZE;
        
        canvas.width = gameWidth;
        canvas.height = gameHeight;
        
        const nextSize = Math.max(120, BLOCK_SIZE * 5);
        nextCanvas1.width = nextSize;
        nextCanvas1.height = nextSize;
        nextCanvas2.width = nextSize;
        nextCanvas2.height = nextSize;
        
        console.log(`デバイス情報: ${JSON.stringify(getDeviceInfo())}`);
        console.log(`ブロックサイズ: ${BLOCK_SIZE}px, キャンバス: ${gameWidth}x${gameHeight}, Next: ${nextSize}x${nextSize}`);
    }

    // --------------------- Game State ---------------------
    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let score = 0;
    let isGameOver = false;
    let isPaused = false;
    let dropCounter = 0;
    let dropInterval = INITIAL_DROP_INTERVAL;
    let lastTime = 0;
    let animationFrameId;
    let combo = 0;
    let maxCombo = 0;
    let particles = [];

    // --------------------- Tetrominos ---------------------
    const tetrominos = [
      {matrix:[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], color:'cyan'},
      {matrix:[[1,1],[1,1]], color:'yellow'},
      {matrix:[[0,1,0],[1,1,1],[0,0,0]], color:'purple'},
      {matrix:[[0,0,1],[1,1,1],[0,0,0]], color:'orange'},
      {matrix:[[1,0,0],[1,1,1],[0,0,0]], color:'blue'},
      {matrix:[[1,1,0],[0,1,1],[0,0,0]], color:'red'},
      {matrix:[[0,1,1],[1,1,0],[0,0,0]], color:'green'}
    ];

    // --------------------- Block Management ---------------------
    let currentBlock = null;
    let nextBlocks = [];
    let lastUsedIndex = -1;

    function createRandomBlock(){
        let index;
        do { index = Math.floor(Math.random()*tetrominos.length); }
        while(index === lastUsedIndex);
        lastUsedIndex = index;
        const t = tetrominos[index];
        return {matrix:t.matrix, color:t.color};
    }

    function getNextBlock(){
        if(nextBlocks.length === 0){
            nextBlocks.push(createRandomBlock());
            nextBlocks.push(createRandomBlock());
        }
        const block = nextBlocks.shift();
        nextBlocks.push(createRandomBlock());
        return {
            matrix:block.matrix,
            color:block.color,
            x:Math.floor(COLS/2)-Math.floor(block.matrix[0].length/2),
            y:0
        };
    }

    function rotate(matrix){
        return matrix[0].map((_,i)=>matrix.map(row=>row[i]).reverse());
    }

    function collide(board, block){
        if(!block) return false;
        for(let y=0;y<block.matrix.length;y++){
            for(let x=0;x<block.matrix[y].length;x++){
                if(block.matrix[y][x] !== 0){
                    const boardX = block.x + x;
                    const boardY = block.y + y;
                    if(boardX<0 || boardX>=COLS || boardY>=ROWS || (boardY>=0 && board[boardY][boardX]!==0)) return true;
                }
            }
        }
        return false;
    }

    // --------------------- Particle System ---------------------
    class Particle {
        constructor(x, y, color, type = 'spark') {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = Math.random() * -6 - 2;
            this.color = color;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.01;
            this.size = Math.random() * 4 + 2;
            this.type = type;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.2;
            this.life -= this.decay;
        }

        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            
            if (this.type === 'lightning') {
                ctx.fillRect(this.x - 1, this.y - 3, 2, 6);
                ctx.fillRect(this.x - 3, this.y - 1, 6, 2);
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        isDead() {
            return this.life <= 0;
        }
    }

    function createLineEffect(lineY, linesCount, comboLevel) {
        const effectColors = ['#ffffff', '#00ffff', '#ffff00', '#ff00ff', '#ff6600'];
        let effectType = Math.min(linesCount - 1, 3);
        if (comboLevel >= 5) effectType = 4;

        const color = effectColors[effectType];
        const particleType = linesCount >= 2 ? 'lightning' : 'spark';
        
        for (let x = 0; x < COLS; x++) {
            for (let i = 0; i < linesCount + comboLevel; i++) {
                particles.push(new Particle(
                    x * BLOCK_SIZE + BLOCK_SIZE/2,
                    lineY * BLOCK_SIZE + BLOCK_SIZE/2,
                    color,
                    particleType
                ));
            }
        }

        if (comboLevel >= 3) {
            screenShake(comboLevel);
        }

        setTimeout(() => flashLine(lineY, color), 50);
    }

    function flashLine(y, color) {
        context.save();
        context.fillStyle = color;
        context.globalAlpha = 0.8;
        context.fillRect(0, y * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
        context.restore();
    }

    function screenShake(intensity) {
        const originalTransform = canvas.style.transform;
        let shakeCount = intensity * 2;
        
        const shake = () => {
            if (shakeCount <= 0) {
                canvas.style.transform = originalTransform;
                return;
            }
            
            const x = (Math.random() - 0.5) * intensity;
            const y = (Math.random() - 0.5) * intensity;
            canvas.style.transform = `translate(${x}px, ${y}px)`;
            
            shakeCount--;
            setTimeout(shake, 50);
        };
        
        shake();
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].isDead()) {
                particles.splice(i, 1);
            }
        }
    }

    function drawParticles() {
        particles.forEach(particle => particle.draw(context));
    }

    function fixBlock(){
        // ブロックを盤面に固定
        for(let y=0;y<currentBlock.matrix.length;y++){
            for(let x=0;x<currentBlock.matrix[y].length;x++){
                if(currentBlock.matrix[y][x]!==0){
                    board[currentBlock.y+y][currentBlock.x+x] = currentBlock.color;
                }
            }
        }
        
        // 完成したラインをチェック（すべて一度に）
        let linesCleared = [];
        for(let y=0; y<ROWS; y++){
            if(board[y].every(cell=>cell!==0)){
                linesCleared.push(y);
            }
        }
        
        if(linesCleared.length > 0){
            // コンボ更新
            combo++;
            if (combo > maxCombo) {
                maxCombo = combo;
                maxComboElement.textContent = maxCombo;
            }
            
            // エフェクト作成
            linesCleared.forEach(lineY => {
                createLineEffect(lineY, linesCleared.length, Math.min(combo, 5));
            });
            
            // ラインを削除してから新しいラインを上に追加
            // 下から上の順番で処理する必要がある
            const sortedLines = linesCleared.sort((a, b) => b - a);
            
            // 各ラインを削除
            for(let i = 0; i < sortedLines.length; i++){
                board.splice(sortedLines[i], 1);
            }
            
            // 削除したライン数分、上に空のラインを追加
            for(let i = 0; i < linesCleared.length; i++){
                board.unshift(Array(COLS).fill(0));
            }
            
            // スコア更新
            const baseScore = 100 * linesCleared.length * linesCleared.length;
            const comboBonus = combo * 50;
            score += baseScore + comboBonus;
            scoreElement.textContent = score;
            dropInterval = Math.max(dropInterval - DROP_SPEED_INCREMENT, MIN_DROP_INTERVAL);
            
            console.log(`${linesCleared.length}ライン消去！ コンボ: ${combo}`);
        } else {
            combo = 0;
        }
        
        // 次のブロック生成
        currentBlock = getNextBlock();
        if(collide(board,currentBlock)) gameOver();
    }

    function hardDrop(){
        while(!collide(board,currentBlock)) currentBlock.y++;
        currentBlock.y--;
        fixBlock();
    }

    // --------------------- Drawing ---------------------
    function drawBoard(){
        context.fillStyle='#111';
        context.fillRect(0,0,canvas.width,canvas.height);
        for(let y=0;y<ROWS;y++){
            for(let x=0;x<COLS;x++){
                context.strokeStyle='#34495e';
                context.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                if(board[y][x]!==0){
                    context.fillStyle=board[y][x];
                    context.fillRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                    context.strokeStyle='black';
                    context.lineWidth=2;
                    context.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
            }
        }
        const ghost = {...currentBlock};
        while(!collide(board,ghost)) ghost.y++;
        ghost.y--;
        for(let y=0;y<ghost.matrix.length;y++)
            for(let x=0;x<ghost.matrix[y].length;x++)
                if(ghost.matrix[y][x]!==0){
                    context.fillStyle='rgba(255,255,255,0.2)';
                    context.fillRect((ghost.x+x)*BLOCK_SIZE,(ghost.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
        for(let y=0;y<currentBlock.matrix.length;y++)
            for(let x=0;x<currentBlock.matrix[y].length;x++)
                if(currentBlock.matrix[y][x]!==0){
                    context.fillStyle=currentBlock.color;
                    context.fillRect((currentBlock.x+x)*BLOCK_SIZE,(currentBlock.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                    context.strokeStyle='black';
                    context.lineWidth=2;
                    context.strokeRect((currentBlock.x+x)*BLOCK_SIZE,(currentBlock.y+y)*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);
                }
        
        drawParticles();
    }

    function drawNext(){
        if (nextBlocks.length === 0) return;
        
        drawNextBlock(nextContext1, nextBlocks[0], nextCanvas1.width, nextCanvas1.height);
        
        if (nextBlocks.length > 1) {
            drawNextBlock(nextContext2, nextBlocks[1], nextCanvas2.width, nextCanvas2.height);
        }
    }

    function drawNextBlock(context, block, canvasWidth, canvasHeight) {
        context.fillStyle = '#111';
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        
        const gridCols = 5;
        const gridRows = 5;
        const cellWidth = canvasWidth / gridCols;
        const cellHeight = canvasHeight / gridRows;
        
        context.strokeStyle = '#34495e';
        context.lineWidth = 1;
        
        for (let i = 0; i <= gridCols; i++) {
            const x = i * cellWidth;
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, canvasHeight);
            context.stroke();
        }
        
        for (let i = 0; i <= gridRows; i++) {
            const y = i * cellHeight;
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(canvasWidth, y);
            context.stroke();
        }
        
        const blockMatrix = block.matrix;
        const blockCols = blockMatrix[0].length;
        const blockRows = blockMatrix.length;
        
        const startCol = Math.floor((gridCols - blockCols) / 2);
        const startRow = Math.floor((gridRows - blockRows) / 2);
        
        for (let y = 0; y < blockRows; y++) {
            for (let x = 0; x < blockCols; x++) {
                if (blockMatrix[y][x] !== 0) {
                    const drawX = (startCol + x) * cellWidth;
                    const drawY = (startRow + y) * cellHeight;
                    
                    const padding = 2;
                    context.fillStyle = block.color;
                    context.fillRect(
                        drawX + padding, 
                        drawY + padding, 
                        cellWidth - padding * 2, 
                        cellHeight - padding * 2
                    );
                    context.strokeStyle = 'black';
                    context.lineWidth = 2;
                    context.strokeRect(
                        drawX + padding, 
                        drawY + padding, 
                        cellWidth - padding * 2, 
                        cellHeight - padding * 2
                    );
                }
            }
        }
    }

    // --------------------- Update Loop ---------------------
    function update(time=0){
        if(isGameOver || isPaused) return;
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if(dropCounter > dropInterval){
            currentBlock.y++;
            if(collide(board,currentBlock)){
                currentBlock.y--;
                fixBlock();
            }
            dropCounter=0;
        }
        updateParticles();
        drawBoard();
        drawNext();
        animationFrameId = requestAnimationFrame(update);
    }

    // --------------------- Pause & Game Over ---------------------
    function togglePause(){
        isPaused = !isPaused;
        if(isPaused){
            pauseMenu.style.display = 'flex';
            cancelAnimationFrame(animationFrameId);
        } else {
            pauseMenu.style.display = 'none';
            update();
        }
    }

    function gameOver(){
        isGameOver = true;
        cancelAnimationFrame(animationFrameId);
        context.fillStyle='rgba(0,0,0,0.7)';
        context.fillRect(0,0,canvas.width,canvas.height);
        context.fillStyle='white';
        context.font='30px Arial';
        context.textAlign='center';
        context.fillText('ゲームオーバー',canvas.width/2,canvas.height/2);
        setTimeout(resetGame,3000);
    }

    function showMessage(msg) {
        messageText.textContent = msg;
        messageOverlay.style.display = 'flex';
    }

    // --------------------- Reset Game ---------------------
    function resetGame(){
        isGameOver=false;
        isPaused=false;
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        score = 0;
        combo = 0;
        maxCombo = 0;
        particles = [];
        scoreElement.textContent = score;
        maxComboElement.textContent = maxCombo;
        nextBlocks=[];
        lastUsedIndex=-1;
        dropInterval = INITIAL_DROP_INTERVAL;
        dropCounter = 0;
        currentBlock = getNextBlock();
        pauseMenu.style.display = 'none';
        messageOverlay.style.display = 'none';
        canvas.style.transform = '';
        update();
    }

    // --------------------- Screen Transitions ---------------------
    function showGameScreen() {
        homeScreen.style.display = 'none';
        homeScreen.classList.add('hidden');
        gameScreen.style.display = 'flex';
        gameScreen.classList.remove('hidden');
        scoreDisplay.style.display = 'block';
        controls.style.display = 'flex';
        document.body.classList.add('game-active');
        resizeCanvas();
        resetGame();
    }

    function showHomeScreen() {
        homeScreen.style.display = 'flex';
        homeScreen.classList.remove('hidden');
        gameScreen.style.display = 'none';
        gameScreen.classList.add('hidden');
        scoreDisplay.style.display = 'none';
        controls.style.display = 'none';
        document.body.classList.remove('game-active');
        cancelAnimationFrame(animationFrameId);
        pauseMenu.style.display = 'none';
        messageOverlay.style.display = 'none';
    }

    // --------------------- Event Handlers ---------------------
    document.querySelector(".soloBtn").addEventListener("click", showGameScreen);
    document.querySelector(".multiBtn").addEventListener("click", () => {
        showMessage("マルチプレイは準備中！");
    });
    document.querySelector(".overlay-back-button").addEventListener("click", () => {
        messageOverlay.style.display = 'none';
    });
    document.querySelector(".resume-button").addEventListener("click", togglePause);
    document.querySelector(".reset-button").addEventListener("click", resetGame);
    document.querySelector(".home-button").addEventListener("click", showHomeScreen);
    document.querySelector(".pause-button").addEventListener("click", togglePause);
    document.querySelectorAll('.control-button').forEach(button => {
        button.addEventListener('click', () => {
            if(isGameOver || isPaused) return;
            switch (button.dataset.key) {
                case 'ArrowLeft':
                    currentBlock.x--;
                    if (collide(board, currentBlock)) currentBlock.x++;
                    break;
                case 'ArrowRight':
                    currentBlock.x++;
                    if (collide(board, currentBlock)) currentBlock.x--;
                    break;
                case 'ArrowDown':
                    currentBlock.y++;
                    if (collide(board, currentBlock)) {
                        currentBlock.y--;
                        fixBlock();
                    }
                    dropCounter = 0;
                    break;
                case 'ArrowUp':
                    const rotated = rotate(currentBlock.matrix);
                    const prev = currentBlock.matrix;
                    currentBlock.matrix = rotated;
                    if (collide(board, currentBlock)) currentBlock.matrix = prev;
                    break;
                case 'Space':
                    hardDrop();
                    dropCounter = 0;
                    break;
            }
        });
    });
    document.addEventListener('keydown', e => {
        if (isGameOver || isPaused) return;
        switch (e.key) {
            case 'ArrowLeft':
                currentBlock.x--;
                if (collide(board, currentBlock)) currentBlock.x++;
                break;
            case 'ArrowRight':
                currentBlock.x++;
                if (collide(board, currentBlock)) currentBlock.x--;
                break;
            case 'ArrowDown':
                currentBlock.y++;
                if (collide(board, currentBlock)) {
                    currentBlock.y--;
                    fixBlock();
                }
                dropCounter = 0;
                break;
            case 'ArrowUp':
                const rotated = rotate(currentBlock.matrix);
                const prev = currentBlock.matrix;
                currentBlock.matrix = rotated;
                if (collide(board, currentBlock)) currentBlock.matrix = prev;
                break;
            case ' ':
                e.preventDefault();
                hardDrop();
                dropCounter = 0;
                break;
            case 'p':
                togglePause();
                break;
        }
    });

    // --------------------- Resize Handler ---------------------
    window.addEventListener('resize', () => {
        if (gameScreen.style.display !== 'none') {
            resizeCanvas();
        }
    });

    // --------------------- Initialize ---------------------
    resizeCanvas();
  </script>
</body>
</html>
